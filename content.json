{"meta":{"title":"Mr.Zhang's space","subtitle":"","description":"","author":"Mr.Zhang","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2019-12-24T08:58:15.000Z","updated":"2019-12-24T08:59:20.842Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-24T08:57:53.000Z","updated":"2019-12-24T08:58:58.217Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"测试文章","slug":"线程池的常见应用场景","date":"2017-08-10T11:46:25.000Z","updated":"2019-12-25T10:17:39.524Z","comments":true,"path":"技术/20170810-ThreadPool-method.html","link":"","permalink":"http://yoursite.com/%E6%8A%80%E6%9C%AF/20170810-ThreadPool-method.html","excerpt":"虽然python由于GIL的存在，对计算密集型任务处理效率比较低下，但对于常见的IO密集型任务(数据的读写、网络IO数据传输)还是很能提高效率的，如果要为多线程任务创建大量线程。由于线程过多可能会出现许多性能问题，我们可以通过创建线程池来解决此问题。线程池事先定义一组初始化和空闲的线程，当我们需要执行大量任务时，与为每个任务实例化新线程相比显然更优，线程池可以更好得管理并发执行的大量线程","text":"虽然python由于GIL的存在，对计算密集型任务处理效率比较低下，但对于常见的IO密集型任务(数据的读写、网络IO数据传输)还是很能提高效率的，如果要为多线程任务创建大量线程。由于线程过多可能会出现许多性能问题，我们可以通过创建线程池来解决此问题。线程池事先定义一组初始化和空闲的线程，当我们需要执行大量任务时，与为每个任务实例化新线程相比显然更优，线程池可以更好得管理并发执行的大量线程 Pool.map() 将可迭代项分为多个块，作为单独的任务提交给进程池。可利用池中的所有进程。多参数应用同一线程函数。但是结果与参数相对应的顺序返回。 123456789101112131415161718192021import datetimefrom multiprocessing.pool import ThreadPooldef thread_out_test(i): nowtime &#x3D; datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(nowtime,i) return idef main_fun(): output &#x3D; [1,2,3,4,5,6,7,8,9,10] pool &#x3D; ThreadPool(processes&#x3D;10) result_data &#x3D; pool.map(thread_out_test, (i for i in output)) #关闭pool，不再接受新的主进程任务 pool.close() #主进程阻塞后，等待子进程运行完后再关闭主进程 pool.join() print(result_data) return result_dataif __name__ &#x3D;&#x3D; &#39;__main__&#39;: main_fun() Pool.apply_async()/apply() Pool.apply():单独进程运行函数，但是希望当前进程在该函数返回之前一直阻塞 Pool.apply_async():单独进程运行函数，进程池异步执行许多功能调用 或者 调用许多不同的线程函数，结果的顺序不能保证与调用的顺序相同。 1234567891011121314151617181920212223242526import datetimefrom multiprocessing.pool import ThreadPooldef thread_out_test(i): nowtime &#x3D; datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(nowtime,i) return iresult_list &#x3D; []def callback_fun(result): result_list.append(result)def main_fun(): output &#x3D; [1,2,3,4,5,6,7,8,9,10] pool &#x3D; ThreadPool(processes&#x3D;10) for i in output: #可添加异步回调函数 pool.apply_async(thread_out_test, args&#x3D;(i,), callback&#x3D;callback_fun) #关闭pool，不再接受新的主进程任务 pool.close() #主进程阻塞后，等待子进程运行完后再关闭主进程 pool.join() return result_listif __name__ &#x3D;&#x3D; &#39;__main__&#39;: main_fun() 其他详细用法，参见ThreadPool中方法 Pool.map_async() map()方法的异步版本 Pool.starmap() 可迭代对象的元素也是可迭代的数据","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"}]}]}